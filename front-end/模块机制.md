
var fs = require('fs');
var http = require('http');

可以完全避免变量命名冲突污染的问题，但是模块之间的通信需要使用模块中的 exports 对象



## require

require是一个方法，作用是用来加载模块的
在Node中，模块有三种
    * 具名的核心模块，例如fs、http
    * 用户自己编写的模块（就是一个js文件），可以使用require方法加载。相对路径必须加./，否则会报错，因为会将模块认定为一个核心模块

在node中没有全局作用域，只有模块作用域，相当于两个script标签。require方法加载时可以省略后缀名的。

推荐使用省略后缀名的写法

## 既然是模块作用域，如何让模块与模块之间通信

require方法有两个作用：
    * 加载文件模块并执行里面的代码
    * 拿到被加载文件模块导出的接口对象

## 每个文件模块中都提供了一个对象：exports

exports默认是一个空对象，是require方法的返回值
    * exports用来实现不同模块之间的通信
    * 每个模块中都提供了一个exports对象，默认是一个空对象
    * 该对象类似于原型链中的prototype对象，能够向对象中添加数据，另一个模块可以通过require方法返回的exports对象使用这些添加的数据
