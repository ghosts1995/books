## 最简单的协程

```
fun main(args: Array<String>) {
    launch(CommonPool) { // CommonPool暂且理解成线程池, 指定了协程在哪里运行
        delay(1000L) 
        println("World!") 
    }
    println("Hello,")
    Thread.sleep(2000L)
}
```

运行结果: ("Hello," 会立即被打印, 1000毫秒之后, "World!" 会被打印)

```
Hello, 
World!
```

## delay() 方法

在协程里 delay 方法作用等同于线程里的 sleep, 都是休息一段时间, 但不同的是 delay 不会阻塞当前线程, 而像是设置了一个闹钟, 在闹钟未响之前, 运行该协程的线程可以被安排做了别的事情, 当闹钟响起时, 协程就会恢复运行。

## 协程启动后还可以取消

launch 方法有一个返回值, 类型是 Job, Job 有一个 cancel 方法, 调用 cancel 方法可以取消协程, 看一个数羊的例子:

```
fun main(args: Array<String>) {
    val job = launch(CommonPool) {
        var i = 1
        while(true) {
            println("$i little sheep")
            ++i
            delay(500L)  // 每半秒数一只, 一秒可以数两只
        }
    }

    Thread.sleep(1000L)  // 在主线程睡眠期间, 协程里已经数了两只羊
    job.cancel()  // 协程才数了两只羊, 就被取消了
    Thread.sleep(1000L)
    println("main process finished.")
}
```

运行结果是:

```
1 little sheep
2 little sheep
main process finished.
```

如果不调用cancel, 可以数到4只羊.

